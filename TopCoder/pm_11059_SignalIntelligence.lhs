http://community.topcoder.com/stat?c=problem_statement&pm=11059

Gogo has been hired by the newly founded TopCoder Security Agency (TSA) and has
been tasked to encrypt a signal code generated by a radar.

The signal will consist of several positive integers. The order of integers
within the signal is not important and therefore should not be preserved during
encryption. However, there may be duplicate integers, and the number of
occurrences of each integer is important and must be preserved during encryption.

Gogo's idea is to encrypt these integers into a String that consists only of
digits '1' and '0'. The encryption scheme is as follows:

Start with an infinite String consisting solely of '0' characters. The
characters within the string are indexed from left to right 1, 2, 3, ... .

For each input integer X in the signal, Gogo will allocate it within the string.
To do this, he will select an index 2^p, where p is a non-negative integer that
he may choose arbitrarily, but in such way that characters at indices between
2^p and 2^p + X - 1, inclusive, are all equal to '0'. The allocating procedure
consists of replacing all these characters with '1's. This newly created
sequence of consecutive '1' characters is said to represent the allocated integer X.

In order to allow unique decryption, the following property must hold after all
numbers from the signal are allocated. For every two integers from the input signal,
there must be at least one '0' character between the sequences of '1's that
represent these integers.

After all numbers are allocated within the string properly, the '1' character with the
largest index is found and all '0' characters to the right of it are removed.
The obtained finite string is the result of the encryption procedure.

Given integers to encrypt in int[] numbers, return the length of the shortest
string that encrypts them and can be obtained according to the scheme described above.
It is guaranteed that this length will not exceed 2^62.

> encodedLength xs = go xs 0 0
>   where
>     go [] _ _ = 0
>     go [x] s p =
>       let n:_ = dropWhile (<=s) [2^i | i <- [p..]]
>       in x+n-1
>     go (x:xs) s p =
>       let (n,j):_ = dropWhile ((<=s) . fst) [(2^i, i) | i <- [p..]]
>       in go xs (x+n) j

> selections [] = []
> selections (x:xs) = (x, xs) : [ (y, x:ys) | (y, ys) <- selections xs ]

> permutations [] = [[]]
> permutations xs = [ y:zs | (y, ys) <- selections xs
>                          , zs <- permutations ys ]

> encodings msg = [ (encodedLength m, m) | m <- permutations msg ]

> main :: IO ()
> main = do
>   putStrLn "*** Solution for SignalIntelligence ***"
>   answer

> answer = mapM_ go examples
>   where
>     go msg = do
>       let ms = encodings msg
>       print $ minimum $ map fst ms
>
>     examples = [ [1,2,3]
>                , [4,4,2,2]
>                -- , example3 -- Example3 will not work with this approach. Todo: Improve the brute force approach
>                ]

> example3 = [ 1000000000,1000000000,1000000000,1000000000,1000000000,
>              1000000000,1000000000,1000000000,1000000000,1000000000,
>              1000000000,1000000000,1000000000,1000000000,1000000000,
>              1000000000,1000000000,1000000000,1000000000,1000000000 ]
